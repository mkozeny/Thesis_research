package game;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import game.Cell;

import edu.mit.csail.sdg.annotations.Ensures;
import edu.mit.csail.sdg.annotations.Modifies;
import edu.mit.csail.sdg.squander.Squander;
import edu.mit.csail.sdg.squander.annotations.FreshObjects;

public class SoliterSolver {

	private int n;
	
	
	public SoliterSolver(State startState, int n) {
		super();
		this.startState = startState;
		this.n = n;
		this.states = new HashSet<State>();
		this.leftNeighbors = new HashMap<Cell, Cell>();
		this.leftTopNeighbors = new HashMap<Cell, Cell>();
		this.leftBottomNeighbors = new HashMap<Cell, Cell>();
		this.rightNeighbors = new HashMap<Cell, Cell>();
		this.rightTopNeighbors = new HashMap<Cell, Cell>();
		this.rightBottomNeighbors = new HashMap<Cell, Cell>();
	}


	Set<State> states;
	
	State startState;
	
	private Map<Cell, Cell> leftNeighbors;
	
	private Map<Cell, Cell> leftTopNeighbors;
	
	private Map<Cell, Cell> leftBottomNeighbors;
	
	private Map<Cell, Cell> rightNeighbors;
	
	private Map<Cell, Cell> rightTopNeighbors;
	
	private Map<Cell, Cell> rightBottomNeighbors;
	
	
	@Ensures({"return[int] in this.states.elts",
		"return[0] = this.startState",
		"return.length = #this.states.elts",
		 "all i: int | i > 0 && i < return.length  =>" +
		 "(all src, via, dest : return[i-1].cells.elts | src.occupied=1 " +
		 "&& via.occupied=1 && dest.occupied=0  " +
		 //" => return[i] = return[i-1])"// +
		 "&& ((this.leftNeighbors.elts[src] = via && this.leftNeighbors.elts[via] = dest)" +
		 "|| (this.rightNeighbors.elts[src] = via && this.rightNeighbors.elts[via] = dest)" +
		 "|| (this.leftTopNeighbors.elts[src] = via && this.leftTopNeighbors.elts[via] = dest)" +
		 "|| (this.leftBottomNeighbors.elts[src] = via && this.leftBottomNeighbors.elts[via] = dest)" +
		 "|| (this.rightTopNeighbors.elts[src] = via && this.rightTopNeighbors.elts[via] = dest)" +
		 "|| (this.rightBottomNeighbors.elts[src] = via && this.rightBottomNeighbors.elts[via] = dest))" +
			      "=> (all cell1 : return[i-1].cells.elts | " +
			      "(all cell2 : return[i].cells.elts | (cell1 != src && cell1 != via && cell1 != dest)?(cell2.occupied=cell1.occupied):" +
			      "((cell2=src || cell2=via)?(cell2.occupied=0):(cell2.occupied=1)))))"})
	//@Modifies({"Cell.occupied"})
	@Modifies({"Cell.occupied"
		,"return.elems","return.length"
		})
	@FreshObjects(cls = State[].class, num = 1)
	public State [] solveSolitergame()
	{
		return Squander.exe(this);
	}

	
	public void generateStates()
	{
		int statesCount = 0;
		int lastRow = 0;
		for(int i =0; i < this.n; i++)
		{
			lastRow +=1;
			statesCount += lastRow;
		}
		for(Cell actualCell:startState.getCells())
		{
			for(Cell potentialNeighbor:startState.getCells())
			{
				if(potentialNeighbor.getRow() == actualCell.getRow() && potentialNeighbor.getColumn() == actualCell.getColumn() -1)
					leftNeighbors.put(actualCell, potentialNeighbor);
				else if(potentialNeighbor.getRow() == actualCell.getRow() && potentialNeighbor.getColumn() == actualCell.getColumn() +1)
					rightNeighbors.put(actualCell, potentialNeighbor);
				else if(potentialNeighbor.getRow() == actualCell.getRow() -1 && potentialNeighbor.getColumn() == actualCell.getColumn() -1)
					leftTopNeighbors.put(actualCell, potentialNeighbor);
				else if(potentialNeighbor.getRow() == actualCell.getRow() -1 && potentialNeighbor.getColumn() == actualCell.getColumn())
					rightTopNeighbors.put(actualCell, potentialNeighbor);
				else if(potentialNeighbor.getRow() == actualCell.getRow() +1 && potentialNeighbor.getColumn() == actualCell.getColumn())
					leftBottomNeighbors.put(actualCell, potentialNeighbor);
				else if(potentialNeighbor.getRow() == actualCell.getRow() +1 && potentialNeighbor.getColumn() == actualCell.getColumn() +1)
					rightBottomNeighbors.put(actualCell, potentialNeighbor);
			}
		}
		this.states.add(startState);
		for(int i =0; i < statesCount-2; i++)
		{
			State s = new State(this.n);
			int cols = 1;
			for(int j = 0; j< this.n; j++)
			{
				for(int k = 0; k< cols; k++)
				{
					s.getCells().add(new Cell(i,j,0));
				}
				cols++;
			}
			//s.setLeftNeighbors(this.startState.getLeftBottomNeighbors());
			this.states.add(s);
		}
		System.out.println("---COUNT OF STATES: "+this.states.size()+"---");
	}
	
}
