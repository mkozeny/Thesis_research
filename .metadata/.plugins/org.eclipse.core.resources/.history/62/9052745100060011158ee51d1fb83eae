package graph;

import java.util.Arrays;
import java.util.Stack;

public class GraphExtension extends Graph {

	private int l;
	
	private int treshold;
	
	private State bestConfiguration;
	
	private Stack<State> stateStack;
	
	public GraphExtension(int n, int l, int treshold) {
		super(n);
		this.l = l;
		this.treshold = treshold;
		this.bestConfiguration = new State(this.n);
		State initState = new State(this.n);
		this.stateStack = new Stack<State>();
		this.stateStack.push(initState);
	}

	
	public void solveLDominantniMnozinaGrafuProblem()
	{
		while(!stateStack.empty())
		{
			State actualState = stateStack.pop();
			
			if(actualState.isCoveringAllNodes() 
					&& actualState.countOfNodes()<this.bestConfiguration.countOfNodes())
				this.bestConfiguration = actualState;
		}
	}
	
	private void generateFollowers(State actualState)
	{
		boolean [] covering = Arrays.copyOf(actualState.getConfiguration(),actualState.getConfiguration().length);
		for(int neighborhood = 0; neighborhood < this.l; neighborhood++)
		{
			for(int i = 0; i<covering.length; i++)
			{
				if(covering[i])
				{
					for(int j = 0; j < matrixOfIncidency[i].length; j++ )
						covering[j] = covering[j] || this.matrixOfIncidency[i][j];
				}
			}
		}
		for(int i=0; i<covering.length; i++)
		{
			if(!covering[i])
			{
				boolean [] newConfiguration = Arrays.copyOf(actualState.getConfiguration(),actualState.getConfiguration().length);
				newConfiguration[i]=true;
				State newState = new State(this.n);
				newState.setConfiguration(newConfiguration);
				this.stateStack.push(newState);
			}
		}
	}
}
