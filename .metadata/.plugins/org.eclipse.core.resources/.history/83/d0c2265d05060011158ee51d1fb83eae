package graph;

import java.util.Arrays;
import java.util.Stack;

public class GraphExtension extends Graph {

	private int l;
	
	private int treshold;
	
	private State bestConfiguration;
	
	private Stack<State> stateStack;
	
	public GraphExtension(int n, int l, int treshold) {
		super(n);
		this.l = l;
		this.treshold = treshold;
		this.bestConfiguration = new State(this.n);
		State initState = new State(this.n);
		this.stateStack = new Stack<State>();
		this.stateStack.push(initState);
	}

	
	public void solveLDominantniMnozinaGrafuProblem()
	{
		while(!stateStack.empty())
		{
			State actualState = stateStack.pop();
			
			if(actualState.isCoveringAllNodes() 
					&& actualState.countOfNodes()<this.bestConfiguration.countOfNodes())
				this.bestConfiguration = actualState;
		}
	}
	
	private void generateFollowers(State actualState)
	{
		boolean [] coverage = Arrays.copyOf(actualState.getCoverage(),actualState.getCoverage().length);
		boolean [] actStateConf = Arrays.copyOf(actualState.getConfiguration(),actualState.getConfiguration().length);
		int maxOccupiedPosition = getMaxOccupiedPosition(actualState.getConfiguration());
		for(int i=maxOccupiedPosition; i<coverage.length; i++)
		{
			if(!coverage[i])
			{
				boolean [] newConfiguration = Arrays.copyOf(actStateConf,actStateConf.length);
				boolean [] newCovering = Arrays.copyOf(coverage,coverage.length);
				newConfiguration[i]=true;
				State newState = new State(this.n);
				newState.setConfiguration(newConfiguration);
				for(int neighborhood = 0; neighborhood < this.l; neighborhood++)
				{
					for(int j = 0; j<newCovering.length; j++)
					{
						if(newCovering[j])
						{
							for(int k = 0; k < matrixOfIncidency[j].length; k++ )
								newCovering[k] = newCovering[k] || this.matrixOfIncidency[j][k];
						}
					}
				}
				newState.setCoverage(newCovering);
				this.stateStack.push(newState);
			}
		}
	}
	
	private int getMaxOccupiedPosition(boolean [] configuration)
	{
		int max = 0;
		for(int i=0; i<configuration.length; i++)
		{
			if(configuration[i])
				max = i;
		}
		return max;
	}
}
